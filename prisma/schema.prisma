generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// NextAuth.js Models
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]
  tasks         Task[]
  timeEntries   TimeEntry[]
  dailyPlans    DailyPlan[]
  externalItems ExternalItem[]
  calendarEvents CalendarEvent[]
  googleSyncState GoogleSyncState[]
  settings      UserSettings?
  integrationConnections IntegrationConnection[]
  
  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// Application Models
// SQLite doesn't support enums, we'll use strings with comments for documentation
// TaskStatus: 'BACKLOG' | 'PLANNED' | 'SCHEDULED' | 'IN_PROGRESS' | 'DONE' | 'DEFERRED' | 'CANCELED'
// TaskPriority: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT'

model Task {
  id               String         @id @default(cuid())
  userId           String         @map("user_id")
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  title            String
  description      String?
  priority         String?        @default("MEDIUM") // 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT'
  status           String         @default("BACKLOG") // 'BACKLOG' | 'PLANNED' | 'SCHEDULED' | 'IN_PROGRESS' | 'DONE' | 'DEFERRED' | 'CANCELED'
  plannedDate      DateTime?      // The day the task is planned for (board)
  dueDate          DateTime?
  scheduledStart   DateTime?
  scheduledEnd     DateTime?
  estimateMinutes  Int?           // planned effort
  actualMinutes    Int?           @default(0)
  order            Int            @default(0) // sort within column/day
  parentId         String?        @map("parent_id") // self-relation for subtasks
  parent           Task?          @relation("Subtasks", fields: [parentId], references: [id])
  subtasks         Task[]         @relation("Subtasks")
  externalLinks    ExternalItem[] // links to integrations
  calendarEvent    CalendarEvent?
  timeEntries      TimeEntry[]
  rolloverCount    Int            @default(0)
  rolledOverFromId String?        @map("rolled_over_from_id")
  deferredTo       DateTime?
  deferralReason   String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([userId, plannedDate, status])
  @@index([userId, parentId])
  @@index([userId, status])
  @@index([plannedDate])
  @@map("tasks")
}

// Time tracking entries
model TimeEntry {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  taskId          String    @map("task_id")
  task            Task      @relation(fields: [taskId], references: [id], onDelete: Cascade)
  startedAt       DateTime  @map("started_at")
  endedAt         DateTime? @map("ended_at")
  durationMinutes Int?      @map("duration_minutes") // computed on end
  createdAt       DateTime  @default(now()) @map("created_at")

  @@index([userId, taskId, startedAt])
  @@index([userId, startedAt])
  @@map("time_entries")
}

// Daily planning and capacity tracking
model DailyPlan {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  date            DateTime
  capacityMinutes Int       @map("capacity_minutes") // from UserSettings
  plannedMinutes  Int       @default(0) @map("planned_minutes")
  startedAt       DateTime? @map("started_at")
  completedAt     DateTime? @map("completed_at")
  notes           String?
  summary         String?
  createdAt       DateTime  @default(now()) @map("created_at")

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@map("daily_plans")
}

// External integration items
model ExternalItem {
  id           String    @id @default(cuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider     String    // 'google_calendar' | 'gmail' | 'github' | 'notion' | 'slack'
  externalId   String    @map("external_id")
  externalUrl  String?   @map("external_url")
  direction    String    // 'import' | 'export' | 'two-way'
  data         String?   // JSON string for SQLite
  lastSyncedAt DateTime? @map("last_synced_at")
  taskId       String?   @map("task_id")
  task         Task?     @relation(fields: [taskId], references: [id], onDelete: SetNull)
  createdAt    DateTime  @default(now()) @map("created_at")

  @@unique([provider, externalId])
  @@index([userId, provider])
  @@index([taskId])
  @@map("external_items")
}

// Calendar event synchronization
model CalendarEvent {
  id           String    @id @default(cuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  taskId       String    @unique @map("task_id")
  task         Task      @relation(fields: [taskId], references: [id], onDelete: Cascade)
  provider     String    // 'google'
  calendarId   String    @map("calendar_id")
  eventId      String    @map("event_id") // Google event id
  iCalUID      String?   @map("ical_uid")
  start        DateTime
  end          DateTime
  etag         String?
  sequence     Int?
  lastSyncedAt DateTime? @map("last_synced_at")
  createdAt    DateTime  @default(now()) @map("created_at")

  @@index([provider, calendarId, eventId])
  @@index([userId, provider])
  @@map("calendar_events")
}

// Google Calendar sync state
model GoogleSyncState {
  id          String    @id @default(cuid())
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  resourceId  String    @map("resource_id") // from watch
  channelId   String    @map("channel_id")
  calendarId  String    @map("calendar_id")
  expiration  DateTime
  syncToken   String?   @map("sync_token")
  createdAt   DateTime  @default(now()) @map("created_at")

  @@unique([channelId])
  @@index([userId, calendarId])
  @@map("google_sync_state")
}

// User settings and preferences
model UserSettings {
  userId                      String  @id @map("user_id")
  user                        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  timezone                    String  @default("UTC")
  workdayStart                Int     @default(9) @map("workday_start") // 24h
  workdayEnd                  Int     @default(17) @map("workday_end")
  weekStart                   Int     @default(1) @map("week_start") // 1 Monday
  defaultDailyCapacityMinutes Int     @default(360) @map("default_daily_capacity_minutes")
  dailyShutdownHour           Int     @default(17) @map("daily_shutdown_hour")
  autoSyncCalendar            Boolean @default(false) @map("auto_sync_calendar")
  autoCreateCalendarEvents    Boolean @default(false) @map("auto_create_calendar_events")
  autoRollover                Boolean @default(true) @map("auto_rollover")
  slackWebhookUrl             String? @map("slack_webhook_url")

  @@map("user_settings")
}

// Integration connections for non-OAuth providers (Slack, Notion, etc)
model IntegrationConnection {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider     String   // "notion", "slack", etc.
  accessToken  String   @map("access_token")
  refreshToken String?  @map("refresh_token")
  expiresAt    DateTime? @map("expires_at")
  scope        String?
  metadata     String?  // JSON string for provider-specific data
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@unique([userId, provider])
  @@index([userId])
  @@map("integration_connections")
}
